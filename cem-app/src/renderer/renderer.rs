use std::{
    num::NonZero,
    ops::Deref,
    sync::Arc,
};

use bevy_ecs::resource::Resource;
use cem_util::wgpu::{
    buffer::{
        WriteStaging,
        WriteStagingCommit,
        WriteStagingTransaction,
    },
    create_texture_from_linsrgba,
    create_texture_view_from_texture,
};
use palette::LinSrgba;

use crate::{
    app::WgpuContext,
    debug::DebugUi,
    renderer::{
        mesh::WindingOrder,
        pipeline::{
            DepthState,
            Stencil,
            StencilTest,
            clear::{
                ClearPipeline,
                ClearPipelineDescriptor,
            },
            mesh::{
                MeshPipeline,
                MeshPipelineDescriptor,
                StencilStateExt,
            },
        },
    },
};

#[derive(Clone, Copy, Debug)]
pub struct RendererConfig {
    pub target_texture_format: wgpu::TextureFormat,
    pub depth_texture_format: Option<wgpu::TextureFormat>,
    pub multisample_count: NonZero<u32>,
}

#[derive(Debug)]
pub struct Renderer {
    pub wgpu_context: WgpuContext,
    config: RendererConfig,

    pub camera_bind_group_layout: wgpu::BindGroupLayout,
    pub mesh_bind_group_layout: wgpu::BindGroupLayout,

    // this is actually used for everything, not just meshes. but we might split it into clear,
    // mesh, etc.
    mesh_shader_module: wgpu::ShaderModule,

    pub clear_pipeline: ClearPipeline,
    pub mesh_opaque_pipeline: MeshPipeline,
    pub mesh_transparent_pipeline: MeshPipeline,
    pub wireframe_pipeline: MeshPipeline,
    pub outline_pipeline: MeshPipeline,

    /// Fallbacks for textures and sampler
    pub fallbacks: Fallbacks,
    // /// Command queue to asynchronously send commands to the renderer.
    // ///
    // /// The queue is checked in [`prepare_world`](Self::prepare_world). Senders
    // /// are e.g. handed out to
    // /// [`TextureSender`s](texture_channel::TextureSender).
    //pub command_queue: CommandQueue,
}

impl Renderer {
    /// The winding order used by the renderer (indicating the front face of a
    /// polygon).
    ///
    /// Apparently this is the default for left-handed coordinate systems (not
    /// sure why it matters). We use this either way, and will tell the
    /// vertex shader to fix the ordering for meshes that are wound opposite
    /// (the ones generated by parry clockwise apparently)
    pub const WINDING_ORDER: WindingOrder = WindingOrder::CounterClockwise;

    pub const MESH_SHADER_MODULE: wgpu::ShaderModuleDescriptor<'static> =
        wgpu::include_wgsl!("mesh.wgsl");

    // We need to flip the interpretation of the winding order here, because this
    // actually depends on the orientation of our Z axis.
    pub const FRONT_FACE: wgpu::FrontFace = Renderer::WINDING_ORDER.flipped().front_face();

    pub fn new(wgpu_context: WgpuContext, config: RendererConfig) -> Self {
        let camera_bind_group_layout =
            wgpu_context
                .device
                .create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                    label: Some("camera_bind_group_layout"),
                    entries: &[
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                });

        let mesh_bind_group_layout = {
            let vertex_buffer = |binding| {
                wgpu::BindGroupLayoutEntry {
                    binding,
                    visibility: wgpu::ShaderStages::VERTEX,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                }
            };

            let texture = |binding| {
                wgpu::BindGroupLayoutEntry {
                    binding,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                        view_dimension: wgpu::TextureViewDimension::D2,
                        multisampled: false,
                    },
                    count: None,
                }
            };

            wgpu_context
                .device
                .create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                    label: Some("mesh_bind_group_layout"),
                    entries: &[
                        // index buffer
                        vertex_buffer(0),
                        // vertex buffer
                        vertex_buffer(1),
                        // sampler
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::FRAGMENT,
                            ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                            count: None,
                        },
                        // material - albedo
                        texture(3),
                        // material - material
                        texture(4),
                    ],
                })
        };

        let mesh_shader_module = wgpu_context
            .device
            .create_shader_module(Self::MESH_SHADER_MODULE);

        let clear_pipeline = ClearPipeline::new(
            &wgpu_context.device,
            &ClearPipelineDescriptor {
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                shader_module: &mesh_shader_module,
            },
        );

        let mesh_opaque_pipeline = MeshPipeline::new(
            &wgpu_context.device,
            &MeshPipelineDescriptor {
                label: "render/mesh/opaque",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(true, wgpu::CompareFunction::Less),
                stencil_state: wgpu::StencilState::new(Some(Stencil::OUTLINE), None),
                topology: wgpu::PrimitiveTopology::TriangleList,
                vertex_shader_entry_point: "vs_main_solid",
                fragment_shader_entry_point: "fs_main_solid",
                alpha_blending: false,
            },
        );

        let mesh_transparent_pipeline = MeshPipeline::new(
            &wgpu_context.device,
            &MeshPipelineDescriptor {
                label: "render/mesh/transparent",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(false, wgpu::CompareFunction::Less),
                stencil_state: wgpu::StencilState::new(Some(Stencil::OUTLINE), None),
                topology: wgpu::PrimitiveTopology::TriangleList,
                vertex_shader_entry_point: "vs_main_solid",
                fragment_shader_entry_point: "fs_main_solid",
                alpha_blending: true,
            },
        );

        let wireframe_pipeline = MeshPipeline::new(
            &wgpu_context.device,
            &MeshPipelineDescriptor {
                label: "render/mesh/wireframe",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(true, wgpu::CompareFunction::LessEqual),
                stencil_state: Default::default(),
                topology: wgpu::PrimitiveTopology::LineList,
                vertex_shader_entry_point: "vs_main_wireframe",
                fragment_shader_entry_point: "fs_main_flat",
                alpha_blending: true,
            },
        );

        // the outline pipeline will draw a scaled version of the mesh with a solid
        // color. it will ignore depth tests, but will check if the OUTLINE bit
        // in the stencil mask is not set
        let outline_pipeline = MeshPipeline::new(
            &wgpu_context.device,
            &MeshPipelineDescriptor {
                label: "render/mesh/outline",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(false, wgpu::CompareFunction::Always),
                stencil_state: wgpu::StencilState::new(
                    None,
                    Some(StencilTest {
                        read_mask: Stencil::OUTLINE,
                        compare: wgpu::CompareFunction::NotEqual,
                    }),
                ),
                topology: wgpu::PrimitiveTopology::TriangleList,
                vertex_shader_entry_point: "vs_main_outline",
                fragment_shader_entry_point: "fs_main_flat",
                alpha_blending: true,
            },
        );

        let mut command_encoder =
            wgpu_context
                .device
                .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                    label: Some("render/init"),
                });
        let mut write_staging = WriteStagingTransaction::new(
            wgpu_context.staging_pool.belt(),
            &wgpu_context.device,
            &mut command_encoder,
        );

        let fallbacks = Fallbacks::new(&wgpu_context.device, &mut write_staging);

        write_staging.commit();
        wgpu_context.queue.submit([command_encoder.finish()]);

        Self {
            wgpu_context,
            config,
            camera_bind_group_layout,
            mesh_bind_group_layout,
            mesh_shader_module,
            clear_pipeline,
            mesh_opaque_pipeline,
            mesh_transparent_pipeline,
            wireframe_pipeline,
            outline_pipeline,
            fallbacks,
            // command_queue: CommandQueue::default(),
        }
    }

    pub fn wgpu_context(&self) -> &WgpuContext {
        &self.wgpu_context
    }

    pub fn config(&self) -> &RendererConfig {
        &self.config
    }
}

impl DebugUi for Renderer {
    fn show_debug(&self, ui: &mut egui::Ui) {
        ui.label(format!(
            "Surface texture: {:?}",
            self.config.target_texture_format
        ));
        ui.label(format!(
            "Depth texture: {:?}",
            self.config.depth_texture_format
        ));
        ui.label(format!(
            "Multisampling: {:?}",
            self.config.multisample_count
        ));
    }
}

// todo: bevy-migrate: this should be as hidden as possible. but it needs to be
// pub for grab_draw_list. although the whole module is not pub.
#[derive(Clone, Debug, Resource)]
pub struct SharedRenderer(pub Arc<Renderer>);

impl Deref for SharedRenderer {
    type Target = Renderer;

    fn deref(&self) -> &Self::Target {
        &*self.0
    }
}

#[derive(Clone, Debug)]
pub struct Fallbacks {
    pub white: wgpu::TextureView,
    pub black: wgpu::TextureView,
    pub sampler: wgpu::Sampler,
}

impl Fallbacks {
    pub fn new<S>(device: &wgpu::Device, mut write_staging: S) -> Self
    where
        S: WriteStaging,
    {
        let white = create_texture_from_linsrgba(
            LinSrgba::new(255, 255, 255, 255),
            wgpu::TextureUsages::TEXTURE_BINDING,
            "white",
            device,
            &mut write_staging,
        );
        let white = create_texture_view_from_texture(&white, "white");

        let black = create_texture_from_linsrgba(
            LinSrgba::new(0, 0, 0, 255),
            wgpu::TextureUsages::TEXTURE_BINDING,
            "black",
            device,
            &mut write_staging,
        );
        let black = create_texture_view_from_texture(&black, "black");

        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("default texture sampler"),
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Linear,
            min_filter: wgpu::FilterMode::Nearest,
            ..Default::default()
        });

        Self {
            white,
            black,
            sampler,
        }
    }
}

// todo: we might need this later
#[derive(Clone, derive_more::Debug)]
struct EguiWgpuRenderer {
    #[debug(skip)]
    inner: Arc<egui::mutex::RwLock<egui_wgpu::Renderer>>,
}

impl From<Arc<egui::mutex::RwLock<egui_wgpu::Renderer>>> for EguiWgpuRenderer {
    fn from(value: Arc<egui::mutex::RwLock<egui_wgpu::Renderer>>) -> Self {
        Self { inner: value }
    }
}
