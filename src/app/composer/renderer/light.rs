use bytemuck::{
    Pod,
    Zeroable,
};
use palette::{
    LinSrgba,
    Srgb,
    WithAlpha,
};

/// Material properties that define how an object looks in the scene.
///
/// This defines how the light from point sources and ambient light it modulated
/// by the objects surface.
///
/// It also defines the colors for wireframe and outline rendering.
///
/// Note that these are only visual properties!
#[derive(Clone, Copy, Debug)]
pub struct Material {
    pub ambient: Srgb,
    pub diffuse: Srgb,
    pub specular: Srgb,
    pub emissive: Srgb,
    pub shininess: f32,
    pub wireframe: Srgb,
    pub outline: Srgb,
}

impl From<Srgb> for Material {
    fn from(value: Srgb) -> Self {
        Self {
            ambient: value,
            diffuse: value,
            specular: Srgb::new(1.0, 1.0, 1.0),
            emissive: Srgb::new(0.0, 0.0, 0.0),
            shininess: 8.0,
            wireframe: Srgb::new(0.0, 0.0, 0.0),
            outline: Srgb::new(0.0, 0.0, 0.0),
        }
    }
}

impl From<Srgb<u8>> for Material {
    fn from(value: Srgb<u8>) -> Self {
        Self::from(value.into_format::<f32>())
    }
}

/// A point light source.
///
/// This defines the color of the light that can be reflected diffusely or
/// specularly.
///
/// Note that we intend to only support one light source at a time, since there
/// isn't much need for more.
///
/// # TODO
///
/// This is currently not used. At the moment we only want one point light
/// specific for a camera, colocated with it. The camera position (and thus the
/// light's) is already sent to the shader. The diffuse and specular light
/// components can be modulated by the camera as well. So there is no need for
/// this right now.
#[derive(Clone, Copy, Debug)]
pub struct PointLight {
    pub diffuse: Srgb,
    pub specular: Srgb,
}

impl PointLight {
    pub const WHITE: Self = Self::from_single_color(Srgb::new(1.0, 1.0, 1.0));

    pub const fn from_single_color(color: Srgb) -> Self {
        Self {
            diffuse: color,
            specular: color,
        }
    }
}

impl Default for PointLight {
    fn default() -> Self {
        Self::WHITE
    }
}

impl From<Srgb> for PointLight {
    fn from(value: Srgb) -> Self {
        Self::from_single_color(value)
    }
}

impl From<Srgb<u8>> for PointLight {
    fn from(value: Srgb<u8>) -> Self {
        Self::from(value.into_format::<f32>())
    }
}

/// Defines filters for lighting components per camera.
///
/// Notably this is the only place to specify ambient lighting. Ambient light is
/// assumed to be bright white everywhere, but it can be modulated by the
/// camera.
///
/// The other components are multiplied with the color generated by the light
/// from a light source or light emitted by the material itself.
#[derive(Clone, Copy, Debug, Pod, Zeroable)]
#[repr(C)]
pub struct CameraLightFilter {
    pub ambient: LinSrgba,
    pub diffuse: LinSrgba,
    pub specular: LinSrgba,
    pub emissive: LinSrgba,
}

impl Default for CameraLightFilter {
    fn default() -> Self {
        // todo: in default operation these should all be white. the materials specify
        // the ratios
        let rgb1 = |x| LinSrgba::new(x, x, x, 1.0);
        Self {
            ambient: rgb1(0.1),
            diffuse: rgb1(0.7),
            specular: rgb1(0.5),
            emissive: rgb1(0.0),
        }
    }
}

#[derive(Clone, Copy, Debug, Pod, Zeroable)]
#[repr(C)]
pub struct MaterialData {
    wireframe: LinSrgba,
    outline: LinSrgba,
    ambient: LinSrgba,
    diffuse: LinSrgba,
    specular: LinSrgba,
    emissive: LinSrgba,
    shininess: f32,
    _padding: [u32; 3],
}

impl MaterialData {
    pub fn new(material: &Material) -> Self {
        Self {
            wireframe: material.wireframe.into_linear().with_alpha(1.0),
            outline: material.outline.into_linear().with_alpha(1.0),
            ambient: material.ambient.into_linear().with_alpha(1.0),
            diffuse: material.diffuse.into_linear().with_alpha(1.0),
            specular: material.specular.into_linear().with_alpha(1.0),
            emissive: material.emissive.into_linear().with_alpha(1.0),
            shininess: material.shininess,
            _padding: Default::default(),
        }
    }
}

#[derive(Clone, Copy, Debug, Pod, Zeroable)]
#[repr(C)]
pub struct PointLightData {
    pub diffuse: LinSrgba,
    pub specular: LinSrgba,
}

impl PointLightData {
    pub fn new(point_light: &PointLight) -> Self {
        Self {
            diffuse: point_light.diffuse.into_linear().with_alpha(1.0),
            specular: point_light.specular.into_linear().with_alpha(1.0),
        }
    }
}
