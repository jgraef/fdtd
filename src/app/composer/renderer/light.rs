use bytemuck::{
    Pod,
    Zeroable,
};
use palette::{
    LinSrgba,
    Srgb,
    Srgba,
    WithAlpha,
};
use serde::{
    Deserialize,
    Serialize,
};

use crate::app::composer::renderer::Outline;

/// Material properties that define how an object looks in the scene.
///
/// This defines how the light from point sources and ambient light it modulated
/// by the objects surface.
///
/// It also defines the colors for wireframe and outline rendering.
///
/// Note that these are only visual properties!
///
/// # TODO: Needs to know if this is transparent, so we can sort by depth.
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub struct Material {
    #[serde(with = "crate::util::serde::palette")]
    pub ambient: Srgba,

    #[serde(with = "crate::util::serde::palette")]
    pub diffuse: Srgba,

    #[serde(with = "crate::util::serde::palette")]
    pub specular: Srgba,

    #[serde(with = "crate::util::serde::palette")]
    pub emissive: Srgba,

    pub shininess: f32,

    #[serde(with = "crate::util::serde::palette")]
    pub wireframe: Srgba,
}

impl From<Srgba> for Material {
    fn from(value: Srgba) -> Self {
        Self {
            ambient: value,
            diffuse: value,
            specular: Srgba::new(1.0, 1.0, 1.0, 1.0),
            emissive: Srgba::new(0.0, 0.0, 0.0, 1.0),
            shininess: 8.0,
            wireframe: Srgba::new(0.0, 0.0, 0.0, 1.0),
        }
    }
}

impl From<Srgba<u8>> for Material {
    fn from(value: Srgba<u8>) -> Self {
        Self::from(value.into_format::<f32, f32>())
    }
}

impl From<Srgb> for Material {
    fn from(value: Srgb) -> Self {
        Self::from(value.with_alpha(1.0))
    }
}

impl From<Srgb<u8>> for Material {
    fn from(value: Srgb<u8>) -> Self {
        Self::from(value.with_alpha(255))
    }
}

/// A point light source.
///
/// This defines the color of the light that can be reflected diffusely or
/// specularly.
///
/// Note that we intend to only support one light source at a time, since there
/// isn't much need for more.
///
/// # TODO
///
/// This is currently not used. At the moment we only want one point light
/// specific for a camera, colocated with it. The camera position (and thus the
/// light's) is already sent to the shader. The diffuse and specular light
/// components can be modulated by the camera as well. So there is no need for
/// this right now.
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub struct PointLight {
    #[serde(with = "crate::util::serde::palette")]
    pub diffuse: Srgb,

    #[serde(with = "crate::util::serde::palette")]
    pub specular: Srgb,
}

impl PointLight {
    pub const WHITE: Self = Self::from_single_color(Srgb::new(1.0, 1.0, 1.0));

    pub const fn from_single_color(color: Srgb) -> Self {
        Self {
            diffuse: color,
            specular: color,
        }
    }
}

impl Default for PointLight {
    fn default() -> Self {
        Self::WHITE
    }
}

impl From<Srgb> for PointLight {
    fn from(value: Srgb) -> Self {
        Self::from_single_color(value)
    }
}

impl From<Srgb<u8>> for PointLight {
    fn from(value: Srgb<u8>) -> Self {
        Self::from(value.into_format::<f32>())
    }
}

/// Defines filters for lighting components per camera.
///
/// Notably this is the only place to specify ambient lighting. Ambient light is
/// assumed to be bright white everywhere, but it can be modulated by the
/// camera.
///
/// The other components are multiplied with the color generated by the light
/// from a light source or light emitted by the material itself.
#[derive(Clone, Copy, Debug, Pod, Zeroable, Serialize, Deserialize)]
#[repr(C)]
pub struct CameraLightFilter {
    #[serde(with = "crate::util::serde::palette")]
    pub ambient: LinSrgba,

    #[serde(with = "crate::util::serde::palette")]
    pub diffuse: LinSrgba,

    #[serde(with = "crate::util::serde::palette")]
    pub specular: LinSrgba,

    #[serde(with = "crate::util::serde::palette")]
    pub emissive: LinSrgba,
}

impl Default for CameraLightFilter {
    fn default() -> Self {
        // todo: in default operation these should all be white. the materials specify
        // the ratios
        let rgb1 = |x| LinSrgba::new(x, x, x, 1.0);
        Self {
            ambient: rgb1(0.3),
            diffuse: rgb1(0.7),
            specular: rgb1(0.5),
            emissive: rgb1(1.0),
        }
    }
}

#[derive(Clone, Copy, Debug, Pod, Zeroable)]
#[repr(C)]
pub struct MaterialData {
    wireframe: LinSrgba,
    outline: LinSrgba,
    ambient: LinSrgba,
    diffuse: LinSrgba,
    specular: LinSrgba,
    emissive: LinSrgba,
    shininess: f32,
    outline_thickness: f32,
    _padding: [u32; 2],
}

impl MaterialData {
    pub fn new(material: &Material, outline: Option<&Outline>) -> Self {
        let (outline, outline_thickness) = outline
            .map(|outline| (outline.color.into_linear(), outline.thickness))
            .unwrap_or_default();

        Self {
            wireframe: material.wireframe.into_linear(),
            outline,
            ambient: material.ambient.into_linear(),
            diffuse: material.diffuse.into_linear(),
            specular: material.specular.into_linear(),
            emissive: material.emissive.into_linear(),
            shininess: material.shininess,
            outline_thickness,
            _padding: [0; _],
        }
    }
}

#[derive(Clone, Copy, Debug, Pod, Zeroable)]
#[repr(C)]
pub struct PointLightData {
    pub diffuse: LinSrgba,
    pub specular: LinSrgba,
}

impl PointLightData {
    pub fn new(point_light: &PointLight) -> Self {
        Self {
            diffuse: point_light.diffuse.into_linear().with_alpha(1.0),
            specular: point_light.specular.into_linear().with_alpha(1.0),
        }
    }
}
