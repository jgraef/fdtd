use std::{
    num::NonZero,
    ops::Deref,
    sync::Arc,
};

use bevy_ecs::resource::Resource;
use cem_util::wgpu::{
    buffer::{
        StagingPool,
        WriteStaging,
        WriteStagingCommit,
        WriteStagingTransaction,
    },
    create_texture_from_linsrgba,
    create_texture_view_from_texture,
};
use palette::LinSrgba;

use crate::{
    mesh::WindingOrder,
    pipeline::{
        DepthState,
        Stencil,
        StencilTest,
        clear::{
            ClearPipeline,
            ClearPipelineDescriptor,
        },
        mesh::{
            MeshPipeline,
            MeshPipelineDescriptor,
            StencilStateExt,
        },
    },
};

#[derive(Clone, Copy, Debug)]
pub struct RendererConfig {
    pub target_texture_format: wgpu::TextureFormat,
    pub depth_texture_format: Option<wgpu::TextureFormat>,
    pub multisample_count: NonZero<u32>,
}

#[derive(Debug)]
pub struct Renderer {
    pub device: wgpu::Device,
    pub queue: wgpu::Queue,
    pub staging_pool: StagingPool,
    pub config: RendererConfig,

    pub camera_bind_group_layout: wgpu::BindGroupLayout,
    pub mesh_bind_group_layout: wgpu::BindGroupLayout,

    pub clear_pipeline: ClearPipeline,
    pub mesh_opaque_pipeline: MeshPipeline,
    pub mesh_transparent_pipeline: MeshPipeline,
    pub wireframe_pipeline: MeshPipeline,
    pub outline_pipeline: MeshPipeline,

    /// Fallbacks for textures and sampler
    pub fallbacks: Fallbacks,
}

impl Renderer {
    /// The winding order used by the renderer (indicating the front face of a
    /// polygon).
    ///
    /// Apparently this is the default for left-handed coordinate systems (not
    /// sure why it matters). We use this either way, and will tell the
    /// vertex shader to fix the ordering for meshes that are wound opposite
    /// (the ones generated by parry clockwise apparently)
    pub const WINDING_ORDER: WindingOrder = WindingOrder::CounterClockwise;

    pub const MESH_SHADER_MODULE: wgpu::ShaderModuleDescriptor<'static> =
        wgpu::include_wgsl!("shader.wgsl");

    // We need to flip the interpretation of the winding order here, because this
    // actually depends on the orientation of our Z axis.
    pub const FRONT_FACE: wgpu::FrontFace = Renderer::WINDING_ORDER.flipped().front_face();

    pub fn new(
        device: wgpu::Device,
        queue: wgpu::Queue,
        staging_pool: StagingPool,
        config: RendererConfig,
    ) -> Self {
        let camera_bind_group_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                label: Some("camera_bind_group_layout"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            });

        let mesh_bind_group_layout = {
            let vertex_buffer = |binding| {
                wgpu::BindGroupLayoutEntry {
                    binding,
                    visibility: wgpu::ShaderStages::VERTEX,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                }
            };

            let texture = |binding| {
                wgpu::BindGroupLayoutEntry {
                    binding,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                        view_dimension: wgpu::TextureViewDimension::D2,
                        multisampled: false,
                    },
                    count: None,
                }
            };

            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                label: Some("mesh_bind_group_layout"),
                entries: &[
                    // index buffer
                    vertex_buffer(0),
                    // vertex buffer
                    vertex_buffer(1),
                    // sampler
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                        count: None,
                    },
                    // material - albedo
                    texture(3),
                    // material - material
                    texture(4),
                ],
            })
        };

        // this is actually used for everything, not just meshes. but we might split it
        // into clear, mesh, etc.
        let mesh_shader_module = device.create_shader_module(Self::MESH_SHADER_MODULE);

        let clear_pipeline = ClearPipeline::new(
            &device,
            &ClearPipelineDescriptor {
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                shader_module: &mesh_shader_module,
            },
        );

        let mesh_opaque_pipeline = MeshPipeline::new(
            &device,
            &MeshPipelineDescriptor {
                label: "render/mesh/opaque",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(true, wgpu::CompareFunction::Less),
                stencil_state: wgpu::StencilState::new(Some(Stencil::OUTLINE), None),
                topology: wgpu::PrimitiveTopology::TriangleList,
                vertex_shader_entry_point: "vs_main_solid",
                fragment_shader_entry_point: "fs_main_solid",
                alpha_blending: false,
            },
        );

        let mesh_transparent_pipeline = MeshPipeline::new(
            &device,
            &MeshPipelineDescriptor {
                label: "render/mesh/transparent",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(false, wgpu::CompareFunction::Less),
                stencil_state: wgpu::StencilState::new(Some(Stencil::OUTLINE), None),
                topology: wgpu::PrimitiveTopology::TriangleList,
                vertex_shader_entry_point: "vs_main_solid",
                fragment_shader_entry_point: "fs_main_solid",
                alpha_blending: true,
            },
        );

        let wireframe_pipeline = MeshPipeline::new(
            &device,
            &MeshPipelineDescriptor {
                label: "render/mesh/wireframe",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(true, wgpu::CompareFunction::LessEqual),
                stencil_state: Default::default(),
                topology: wgpu::PrimitiveTopology::LineList,
                vertex_shader_entry_point: "vs_main_wireframe",
                fragment_shader_entry_point: "fs_main_flat",
                alpha_blending: true,
            },
        );

        // the outline pipeline will draw a scaled version of the mesh with a solid
        // color. it will ignore depth tests, but will check if the OUTLINE bit
        // in the stencil mask is not set
        let outline_pipeline = MeshPipeline::new(
            &device,
            &MeshPipelineDescriptor {
                label: "render/mesh/outline",
                renderer_config: &config,
                camera_bind_group_layout: &camera_bind_group_layout,
                mesh_bind_group_layout: &mesh_bind_group_layout,
                shader_module: &mesh_shader_module,
                depth_state: DepthState::new(false, wgpu::CompareFunction::Always),
                stencil_state: wgpu::StencilState::new(
                    None,
                    Some(StencilTest {
                        read_mask: Stencil::OUTLINE,
                        compare: wgpu::CompareFunction::NotEqual,
                    }),
                ),
                topology: wgpu::PrimitiveTopology::TriangleList,
                vertex_shader_entry_point: "vs_main_outline",
                fragment_shader_entry_point: "fs_main_flat",
                alpha_blending: true,
            },
        );

        let mut command_encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
            label: Some("render/init"),
        });
        let mut write_staging =
            WriteStagingTransaction::new(staging_pool.belt(), &device, &mut command_encoder);

        let fallbacks = Fallbacks::new(&device, &mut write_staging);

        write_staging.commit();
        queue.submit([command_encoder.finish()]);

        Self {
            device,
            queue,
            staging_pool,
            config,
            camera_bind_group_layout,
            mesh_bind_group_layout,
            clear_pipeline,
            mesh_opaque_pipeline,
            mesh_transparent_pipeline,
            wireframe_pipeline,
            outline_pipeline,
            fallbacks,
        }
    }
}

// todo: render-refactor: this should be as hidden as possible. but it needs to
// be pub for grab_draw_list. although the whole module is not pub.
#[derive(Clone, Debug, Resource)]
pub struct SharedRenderer(pub Arc<Renderer>);

impl Deref for SharedRenderer {
    type Target = Renderer;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[derive(Clone, Debug)]
pub struct Fallbacks {
    pub white: wgpu::TextureView,
    pub black: wgpu::TextureView,
    pub sampler: wgpu::Sampler,
}

impl Fallbacks {
    pub fn new<S>(device: &wgpu::Device, mut write_staging: S) -> Self
    where
        S: WriteStaging,
    {
        let white = create_texture_from_linsrgba(
            LinSrgba::new(255, 255, 255, 255),
            wgpu::TextureUsages::TEXTURE_BINDING,
            "white",
            device,
            &mut write_staging,
        );
        let white = create_texture_view_from_texture(&white, "white");

        let black = create_texture_from_linsrgba(
            LinSrgba::new(0, 0, 0, 255),
            wgpu::TextureUsages::TEXTURE_BINDING,
            "black",
            device,
            &mut write_staging,
        );
        let black = create_texture_view_from_texture(&black, "black");

        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("default texture sampler"),
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Linear,
            min_filter: wgpu::FilterMode::Nearest,
            ..Default::default()
        });

        Self {
            white,
            black,
            sampler,
        }
    }
}
